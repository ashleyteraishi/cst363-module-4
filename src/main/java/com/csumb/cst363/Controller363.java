package com.csumb.cst363;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.ArrayList;

import javax.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;


@Controller    
public class Controller363 {
	
	@Autowired
	private JdbcTemplate jdbcTemplate;
	
	/*
	 * Doctor requests form to create new prescription.
	 */
	@GetMapping("/prescription/new")
	public String newPrescripton(Model model) {
		model.addAttribute("prescription", new Prescription());
		return "prescription_create";
	}
	
	/* 
	 * Process the new prescription form.
	 * 1.  Validate that Doctor SSN exists and matches Doctor Name.
	 * 2.  Validate that Patient SSN exists and matches Patient Name.
	 * 3.  Validate that Drug name exists.
	 * 4.  Insert new prescription.
	 * Return error message and the filled in prescription form
	 *   or the prescription with the rxid number generated by the database.
	 */
	@PostMapping("/prescription")
	public String addPrescription(@Valid Prescription p, BindingResult result, Model model) {
		if (result.hasErrors()) {
			System.out.println("Binding error in addPrescription.");
		}
		System.out.println(p.toString());  // debug -- print form data to console
		
		try {
			Connection conn = getConnection();
			System.out.println("get connection");
			String query = "INSERT INTO prescription "
					+ "(quantity, dr_ssn, patient_ssn, trade_name) "
					+ "VALUES (?, ?, ?, ?) ";
			PreparedStatement ps = conn.prepareStatement(query);
			System.out.println("prepared statement");
			ps.setInt(1, p.getQuantity());
			System.out.println("set int");
			ps.setInt(2, p.getDoctor_ssn());
			System.out.println("set int");
			ps.setInt(3, p.getPatient_ssn());
			System.out.println("set int");
			ps.setString(4, p.getDrugName());
			System.out.println("set string");
			
			ps.executeUpdate();
			System.out.println("execute update");
			conn.close();
			model.addAttribute("prescription", p);
			return "prescription_show";
		}
		
		catch (SQLException se) {
			System.out.println("catch sqlexception");
			return "error";
		}

	}
	
	/* 
	 * patient requests the form to fill a prescription
	 */
	@GetMapping("/prescription/fill")
	public String getfillForm(Model model) {
		model.addAttribute("prescription", new Prescription());
		return "prescription_fill";
	}
	
	/*
	 * process the prescription fill form
	 * 1.  Validate that rxid, pharmacy name and pharmacy address are entered 
	 *     and uniquely identify a prescript and one pharmacy.
	 * 2.  update prescription with pharmacyid, name and address.
	 * 3.  update prescription with today's date.
	 * Display updated prescription 
	 *   or if there is an error show the form with an error message.
	 */
	@PostMapping("/prescription/fill")
	public String processFillForm(@Valid Prescription p, BindingResult result, Model model) {
		if (result.hasErrors()) {
			System.out.println("Binding error in processFillForm.");
		}

		/*
		 * replace the following code with code to validate the rxid, pharmacy name and 
		 * address from the database , and update the pharmacyID, cost and data of 
		 * the prescription
		 */
		p.setPharmacyID("70012345");
		p.setCost(12.504);
		p.setDateFilled( new java.util.Date().toString() );
		
		model.addAttribute("prescription", p);
		return "prescription_show";

	}
	
	/*
	 * process search request for quantity used for each drug for a given pharmacy.
	 * input is pharmacyID, startDate and endDate
	 * output is drugName, quantity used to fill prescriptions
	 * 1.  validate pharmacyID 
	 */
	@GetMapping("/pharmacy")
	public String pharmacyReport(
			@RequestParam("pharmacyID") String pharmacyID,
			@RequestParam("drug") String drug, 
			@RequestParam("startDate") String startDate,
			@RequestParam("endDate") String endDate,
			Model model) {
		System.out.println("pharamcy report. ID="+pharmacyID+", start="+startDate+", end="+endDate);  // for debug 
		
		ArrayList<ReportElement1> drugs = new ArrayList<>();
	
		try {
			Connection conn = getConnection();
			String query = "SELECT trade_name, SUM(quantity) "
					+ "FROM prescription "
					+ "WHERE pharma_id = ? "
					+ "AND fill_date BETWEEN ? AND ? "
					+ "GROUP BY trade_name "
					+ "HAVING trade_name LIKE ? ";
			System.out.println("set connection");
			PreparedStatement ps = conn.prepareStatement(query);
			System.out.println("prepared statement");
			ps.setInt(1, Integer.parseInt(pharmacyID));
			System.out.println("set int");
			ps.setDate(2, Date.valueOf(startDate));
			ps.setDate(3, Date.valueOf(endDate));
			System.out.println("set dates");
			ps.setString(4, drug.trim()+"%");
			System.out.println("set drug name");
			ResultSet rs = ps.executeQuery();
			System.out.println("execute query");
			
			while (rs.next()) {
				String drug_name = rs.getString(1);
				int quantity = rs.getInt(2);
				ReportElement1 re = new ReportElement1(drug_name, quantity);
				drugs.add(re);
			}
			System.out.println("add to drugs");
			
			conn.close();
			model.addAttribute("startDate", startDate);
			model.addAttribute("endDate", endDate);
			model.addAttribute("pharmacyID", pharmacyID);
			model.addAttribute("drug", drug);
			model.addAttribute("report", drugs);
			return "pharmacy_report";
		}
		
		catch (SQLException se) {
			System.out.println("exception caught");
			return "error";
		}
		
	}
	
	
	/* 
	 * process search request for FDA of quantity of drug prescribed by doctor
	 * input is drugname, date range
	 * output is doctor name, quantity prescribed
	 * 1.  validate the drug name (it may be a partial name of a drug)
	 */
	@GetMapping("/fda")
	public String fdaReport(
			@RequestParam("drug") String drug, 
			@RequestParam("startDate") String startDate,
			@RequestParam("endDate") String endDate,
			Model model) {
		System.out.println("fda report. drug="+drug+", start="+startDate+", end="+endDate);  // for debug
		
		ArrayList<ReportElement1> drugs = new ArrayList<>();

		try {
			Connection conn = getConnection();
			String query = "SELECT CONCAT(doctor.first_name, ' ', doctor.last_name), SUM(prescription.quantity) "
					+ "FROM doctor JOIN prescription "
					+ "ON doctor.SSN = prescription.dr_ssn "
					+ "WHERE trade_name LIKE ? "
					+ "AND prescribe_date BETWEEN ? AND ? "
					+ "GROUP BY prescription.dr_ssn ";
			System.out.println("set connection");
			// prepared statement will return the doctor's name and the number of times
			// that doctor has prescribed the drug within the start and end dates
			PreparedStatement ps = conn.prepareStatement(query);
			System.out.println("prepared statement");
			ps.setString(1, drug.trim()+"%");
			System.out.println("set string");
			ps.setDate(2, Date.valueOf(startDate));
			ps.setDate(3, Date.valueOf(endDate));
			System.out.println("set dates");
			ResultSet rs = ps.executeQuery();
			System.out.println("execute query");
			
			// while rs has another element
			while (rs.next()) {
				// report element is the name and quantity returned by the query
				String name = rs.getString(1);
				int quantity = rs.getInt(2);
				ReportElement1 re = new ReportElement1(name, quantity);
				drugs.add(re);
			}
			System.out.println("add to drugs");
			
			// close the connection and return the fda report
			conn.close();
			model.addAttribute("startDate", startDate);
			model.addAttribute("endDate", endDate);
			model.addAttribute("drug", drug);
			model.addAttribute("report", drugs);
			return "fda_report";
		}
		
		// otherwise return the error page
		catch(SQLException se) {
			System.out.println("catch fda report");
			return "error";
		}
		
	}
	
	/*
	 * return JDBC Connection using jdbcTemplate in Spring Server
	 */
	private Connection getConnection() throws SQLException {
		Connection conn = jdbcTemplate.getDataSource().getConnection();
		return conn;
	}
	
}

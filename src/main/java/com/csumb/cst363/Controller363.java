package com.csumb.cst363;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

import javax.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class Controller363 {

	@Autowired
	private JdbcTemplate jdbcTemplate;

	/*
	 * Doctor requests form to create new prescription.
	 */
	@GetMapping("/prescription/new")
	public String newPrescripton(Model model) {
		model.addAttribute("prescription", new Prescription());
		return "prescription_create";
	}

	/*
	 * Process the new prescription form. 1. Validate that Doctor SSN exists and
	 * matches Doctor Name. 2. Validate that Patient SSN exists and matches Patient
	 * Name. 3. Validate that Drug name exists. 4. Insert new prescription. Return
	 * error message and the filled in prescription form or the prescription with
	 * the rxid number generated by the database.
	 */
	@PostMapping("/prescription")
	public String addPrescription(@Valid Prescription p, BindingResult result, Model model) {
		if (result.hasErrors()) {
			System.out.println("Binding error in addPrescription.");
		}
		System.out.println(p.toString()); // debug -- print form data to console

		try {
			// establish connection
			Connection conn = jdbcTemplate.getDataSource().getConnection();

			// first validate the doctor credentials
			// doctor ssn must exist and match the entered doctor name
			PreparedStatement validDrCreds = conn.prepareStatement(
					"select d.ssn, f.ssn, CONCAT(f.first_name, ' ', f.last_name) " + "from doctor as d " + "join doctor as f on d.ssn = f.ssn "
							+ "where d.ssn = f.ssn and f.ssn = ? and CONCAT(f.first_name, ' ', f.last_name) = ?");
			validDrCreds.setInt(1, p.getDoctor_ssn());
			validDrCreds.setString(2, p.getDoctorName());
			ResultSet rs = validDrCreds.executeQuery();
			
			// if the query does not come up with a result, 
			// the entry is invalid
			if (!rs.next()) {
				String docCredError = "Doctor SSN and Name do not match";
				model.addAttribute("msg", docCredError);
				return "error";
			}

			// next validate the patient credentials
			// patient ssn must exist and match the entered patient name
			PreparedStatement validPatientCreds = conn.prepareStatement(
					"select p.ssn, f.ssn, CONCAT(f.first_name, ' ', f.last_name) " + "from patient as p " + "join patient as f on p.ssn = f.ssn "
							+ "where p.ssn = f.ssn and f.ssn = ? and CONCAT(f.first_name, ' ', f.last_name) = ?");
			validPatientCreds.setInt(1, p.getPatient_ssn());
			validPatientCreds.setString(2, p.getPatientName());
			rs = validPatientCreds.executeQuery();
			
			// if the query does not come up with a result,
			// the entry is invalid
			if (!rs.next()) {
				String docCredError = "Patient SSN and Name do not match";
				model.addAttribute("msg", docCredError);
				return "error";
			} 
			
			// next validate that the drug name exists in the db
			PreparedStatement validDrug = conn
					.prepareStatement("select trade_name from drug " + "where trade_name = ?");
			validDrug.setString(1, p.getDrugName());
			rs = validDrug.executeQuery();

			// if the query does not come up with a result,
			// the drug does not exist in the db
			if (!rs.next()) {
				String drugNameError = "This is not a valid drug name";
				model.addAttribute("msg", drugNameError);
				return "error";
			} 

			// finally, if all queries come up with results, insert new prescription into db
			String query = "INSERT INTO prescription " + "(quantity, prescribe_date, dr_ssn, patient_ssn, trade_name) "
					+ "VALUES (?, ?, ?, ?, ?) ";
			PreparedStatement ps = conn.prepareStatement(query);
			ps.setInt(1, p.getQuantity());
			ps.setDate(2, new Date(System.currentTimeMillis()));
			ps.setInt(3, p.getDoctor_ssn());
			ps.setInt(4, p.getPatient_ssn());
			ps.setString(5, p.getDrugName());
			ps.executeUpdate();
			model.addAttribute("prescription", p);
			conn.close();
			return "prescription_show";
		}

		catch (SQLException se) {
			System.out.println("Error:  FirstApp#reviews SQLException " + se.getMessage());
			model.addAttribute("msg", se.getMessage());
			return "error";
		}

	}

	/*
	 * patient requests the form to fill a prescription
	 */
	@GetMapping("/prescription/fill")
	public String getfillForm(Model model) {
		model.addAttribute("prescription", new Prescription());
		return "prescription_fill";
	}

	/*
	 * process the prescription fill form 1. Validate that rxid, pharmacy name and
	 * pharmacy address are entered and uniquely identify a prescript and one
	 * pharmacy. 2. update prescription with pharmacyid, name and address. 3. update
	 * prescription with today's date. Display updated prescription or if there is
	 * an error show the form with an error message.
	 */
	@PostMapping("/prescription/fill")
	public String processFillForm(@Valid Prescription p, BindingResult result, Model model) {
		if (result.hasErrors()) {
			System.out.println("Binding error in processFillForm.");
		}

		/*
		 * replace the following code with code to validate the rxid, pharmacy name and
		 * address from the database , and update the pharmacyID, cost and data of the
		 * prescription
		 */
		
		try {
			// establish connection
			Connection conn = getConnection();
			
			// first verify pharmacy credentials
			// pharmacy name and address must exist and match
			String pharmaQuery = "SELECT pharmacy.pharma_id, pharmacy.pharma_name, pharmacy.pharma_phone, "
					+ "CONCAT(address.address1, ' ', address.city, ', ', address.state, ' ', address.zip_code) "
					+ "FROM address JOIN pharmacy "
					+ "ON address.address_id = pharmacy.address_id "
					+ "WHERE pharmacy.pharma_name = ? "
					+ "AND CONCAT(address.address1, ' ', address.city, ', ', address.state, ' ', address.zip_code) = ?";
			PreparedStatement pharma_ps = conn.prepareStatement(pharmaQuery);
			pharma_ps.setString(1, p.getPharmacyName());
			pharma_ps.setString(2, p.getPharmacyAddress());
			ResultSet pharma_rs = pharma_ps.executeQuery();
			
			// if the query does not come up with a result,
			// the pharmacy data is invalid
			if (!pharma_rs.next()) {
				String pharmaError = "Pharmacy name and address do not match";
				model.addAttribute("msg", pharmaError);
				return "error";
			}
			
			// else set the pharmacy id and pharmacy phone from the result set
			p.setPharmacyID(pharma_rs.getInt(1));
			p.setPharmacyPhone(pharma_rs.getString(3));
			
			// next validate prescription credentials
			// the prescription id must exist
			String prescriptionQuery = "SELECT * FROM prescription WHERE prescription_id = ?";
			PreparedStatement prescription_ps = conn.prepareStatement(prescriptionQuery);
			prescription_ps.setInt(1, p.getRxid());
			ResultSet prescription_rs = prescription_ps.executeQuery();
			
			// if the query does not come up with a result,
			// the prescription id does not exist
			if (!prescription_rs.next()) {
				String prescriptionError = "Prescription id does not exist in the database";
				model.addAttribute("msg", prescriptionError);
				return "error";
			}
			
			// else set dr and patient ssn, drug name, and quantity
			// from the result set
			p.setDoctor_ssn(prescription_rs.getInt(6));
			p.setPatient_ssn(prescription_rs.getInt(7));
			p.setDrugName(prescription_rs.getString(8));
			p.setQuantity(prescription_rs.getInt(2));
			
			// next we need to populate the doctor name field
			String drQuery = "SELECT CONCAT(first_name, ' ', last_name) "
					+ "FROM doctor WHERE SSN = ? ";
			PreparedStatement dr_ps = conn.prepareStatement(drQuery);
			dr_ps.setInt(1, p.getDoctor_ssn());
			ResultSet dr_rs = dr_ps.executeQuery();
			
			// if the query does not come up with a result,
			// no doctor name was found
			if (!dr_rs.next()) {
				String doctorError = "Doctor does not exist";
				model.addAttribute("msg", doctorError);
				return "error";
			}
			
			// else set doctor name from the result set
			p.setDoctorName(dr_rs.getString(1));
			
			// next we need to populate the cost field
			String priceQuery = "SELECT price FROM drug JOIN pharmacy JOIN sells "
					+ "ON drug.trade_name = sells.trade_name "
					+ "AND pharmacy.pharma_id = sells.pharma_id "
					+ "WHERE drug.trade_name = ? ";
			PreparedStatement price_ps = conn.prepareStatement(priceQuery);
			price_ps.setString(1, p.getDrugName());
			ResultSet price_rs = price_ps.executeQuery();
			
			// if the query does not come up with a result,
			// no price was set in the sells table
			if (!price_rs.next()) {
				String doctorError = "Cannot find price";
				model.addAttribute("msg", doctorError);
				return "error";
			}
			
			// else set the cost from the result set
			p.setCost(price_rs.getDouble(1));
			
			// finally, if all queries come up with results, 
			// update the prescription with pharma_id and fill_date
			String updateQuery = "UPDATE prescription "
					+ "SET pharma_id = ?, fill_date = ? "
					+ "WHERE prescription_id = ?";
			PreparedStatement update_ps = conn.prepareStatement(updateQuery);
			update_ps.setInt(1, pharma_rs.getInt(1));
			update_ps.setDate(2, new Date(System.currentTimeMillis()));
			update_ps.setInt(3, prescription_rs.getInt(1));
			update_ps.executeUpdate();
			
			p.setDateFilled(new Date(System.currentTimeMillis()));	
			
			conn.close();
			model.addAttribute("prescription", p);
			return "prescription_show";
			
		}
		catch(SQLException se) {
			model.addAttribute("msg", "Caught Exception");
			return "error";
		}

	}

	/*
	 * process search request for quantity used for each drug for a given pharmacy.
	 * input is pharmacyID, startDate and endDate output is drugName, quantity used
	 * to fill prescriptions 1. validate pharmacyID
	 */
	@GetMapping("/pharmacy")
	public String pharmacyReport(@RequestParam("pharmacyID") String pharmacyID, @RequestParam("drug") String drug,
			@RequestParam("startDate") String startDate, @RequestParam("endDate") String endDate, Model model) {
		System.out.println("pharamcy report. ID=" + pharmacyID + ", start=" + startDate + ", end=" + endDate); // for
																												// debug

		ArrayList<ReportElement1> drugs = new ArrayList<>();

		try {
			// establish connection
			Connection conn = getConnection();
			
			// query to get drug name and quantity prescribed
			String query = "SELECT trade_name, SUM(quantity) " + "FROM prescription " + "WHERE pharma_id = ? "
					+ "AND fill_date BETWEEN ? AND ? " + "GROUP BY trade_name " + "HAVING trade_name LIKE ? ";
			PreparedStatement ps = conn.prepareStatement(query);
			ps.setInt(1, Integer.parseInt(pharmacyID));
			ps.setDate(2, Date.valueOf(startDate));
			ps.setDate(3, Date.valueOf(endDate));
			ps.setString(4, drug.trim() + "%");
			ResultSet rs = ps.executeQuery();

			// if the query returns a result set,
			// display drugs
			if (rs.next()) {
				String drug_name = rs.getString(1);
				int quantity = rs.getInt(2);
				ReportElement1 re = new ReportElement1(drug_name, quantity);
				drugs.add(re);

				conn.close();
				model.addAttribute("startDate", startDate);
				model.addAttribute("endDate", endDate);
				model.addAttribute("pharmacyID", pharmacyID);
				model.addAttribute("drug", drug);
				model.addAttribute("report", drugs);
				return "pharmacy_report";
			}
			// if the query does not return a result,
			// the pharmacy id or drug name is invalid
			else {
				String pharmaError = "Invalid pharmacy id or drug name";
				model.addAttribute("msg", pharmaError);
				return "error";
			}
		}

		catch (SQLException se) {
			model.addAttribute("msg", "Caught Exception");
			return "error";
		}

	}

	/*
	 * process search request for FDA of quantity of drug prescribed by doctor input
	 * is drugname, date range output is doctor name, quantity prescribed 1.
	 * validate the drug name (it may be a partial name of a drug)
	 */
	@GetMapping("/fda")
	public String fdaReport(@RequestParam("drug") String drug, @RequestParam("startDate") String startDate,
			@RequestParam("endDate") String endDate, Model model) {
		System.out.println("fda report. drug=" + drug + ", start=" + startDate + ", end=" + endDate); // for debug

		ArrayList<ReportElement1> drugs = new ArrayList<>();

		try {
			// establish connection
			Connection conn = getConnection();
			
			// query to get doctor name and amount prescribed
			String query = "SELECT CONCAT(doctor.first_name, ' ', doctor.last_name), SUM(prescription.quantity) "
					+ "FROM doctor JOIN prescription " + "ON doctor.SSN = prescription.dr_ssn "
					+ "WHERE trade_name LIKE ? " + "AND prescribe_date BETWEEN ? AND ? "
					+ "GROUP BY prescription.dr_ssn ";
			// prepared statement will return the doctor's name and the number of times
			// that doctor has prescribed the drug within the start and end dates
			PreparedStatement ps = conn.prepareStatement(query);
			ps.setString(1, drug.trim() + "%");
			ps.setDate(2, Date.valueOf(startDate));
			ps.setDate(3, Date.valueOf(endDate));
			ResultSet rs = ps.executeQuery();

			// if the query returns a result, display drugs
			if (rs.next()) {
				String name = rs.getString(1);
				int quantity = rs.getInt(2);
				ReportElement1 re = new ReportElement1(name, quantity);
				drugs.add(re);
				
				// close the connection and return the fda report
				conn.close();
				model.addAttribute("startDate", startDate);
				model.addAttribute("endDate", endDate);
				model.addAttribute("drug", drug);
				model.addAttribute("report", drugs);
				return "fda_report";
			}
			// if the query does not return a result set,
			// the drug name is invalid
			else {
				String fdaError = "Drug name does not exist in the db";
				model.addAttribute("msg", fdaError);
				return "error";
			}
		}

		// otherwise return the error page
		catch (SQLException se) {
			model.addAttribute("msg", "Caught Exception");
			return "error";
		}

	}

	/*
	 * return JDBC Connection using jdbcTemplate in Spring Server
	 */
	private Connection getConnection() throws SQLException {
		Connection conn = jdbcTemplate.getDataSource().getConnection();
		return conn;
	}

}
